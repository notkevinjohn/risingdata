;*******************************************************************************
; File: common.logo
;
;*******************************************************************************
to physical :xlowpix :xhighpix :ylowpix :yhighpix
  make "xlp :xlowpix
  make "xhp :xhighpix
  make "ylp :ylowpix
  make "yhp :yhighpix
end

to geometry :xs :ys :xoff :yoff
  output (word "|-geometry | :xs "x :ys "+ :xoff "+ :yoff)
end

to tile :nh :nv :ht :vt
  let [gap 0.03]
  make "hwid (:xhp - :xlp) / :nh  ; horizontal width
  make "vwid (:yhp - :ylp) / :nv  ; vertical height
  make "geo0 round ((1 - (2 * :gap)) * :hwid)
  make "geo1 round ((1 - (2 * :gap)) * :vwid)
  make "geo2 round (((:ht - 1) * :hwid) + :xlp + (:gap * :hwid))
  make "geo3 round (((:vt - 1) * :vwid) + :ylp + (:gap * :vwid))
  output geometry :geo0 :geo1 :geo2 :geo3
end

to aspect :nh :nv
  let [gap 0.03]
  make "hwid (:xhp - :xlp) / :nh  ; horizontal width
  make "vwid (:yhp - :ylp) / :nv  ; vertical height
  make "geo0 round ((1 - (2 * :gap)) * :hwid)
  make "geo1 round ((1 - (2 * :gap)) * :vwid)
end

to screencapture
  restart-wifi
  blindexec "|/usr/local/i3/tools/ScreenCapture.sh|
end

to restart-run :fcn
  dotimes [i 100000]
    [carefully :fcn [ifelse empty? errormessage [stopme][print errormessage]]
  print se "restarting :i + 1]
end

to display-camera :flags
  make "filename "cam-image.jpg
  blindexec (se "|/usr/local/i3/avconv -f video4linux2 -s 640x480 -i /dev/video1 -ss 0:0:2 -frames 1| :filename)
  wait 50
  display-xv :flags :filename :steadyCamera ;steadyCamera default true in project.logo
end

to display-image :flags :filename  ;file geometry
  display-xv :flags :filename :steadyImage  ;steadyImage default true in project.logo
end

to display-xv :flags :filename :isSteady
  ifelse (:isSteady = true)
    [ if empty? get :filename "already.displayed  ;check if already called
        [ put :filename "already.displayed "true
          blindexec (se "|/usr/local/i3/xv -nodecor -poll -viewonly -nostat| :flags :filename) ] ]
    [blindexec (se "|/usr/local/i3/xv -viewonly -nostat| :flags :filename)]
end

to start-dtach
  blindexec "|/usr/local/i3/tools/dtach.sh|
end

to run-forever
  restart-run [run-loop]
end

to run-loop
;  blindexec "|/usr/local/i3/pkill.sh xv|
  loop [run-once] ;forever loop
end

to receive-packet
  make "packet-bytes retrieve-packet  ;reads the packet off the one-wire
				      ;  network from the app board
  if (count :packet-bytes) > 0        ;make sure packet is not empty
    [ process-header ]                ;check : 1the checksum and type values           
end

to process-header
  make "oldcheck :check  		     ;copy value from new check to old
  let [nws ((first :packet-bytes) / 2) + 1]  ;the checksum is the very last
					     ;  byte in the packet
  make "check wnth :nws :packet-bytes   ;checksum is the last byte in the packet
  ifelse (:check = :oldcheck) 		;if checksums are equal do nothing
    []					; else process packet
    [ make "type nth 1 :packet-bytes ;pull type information out of packet       
      process-data-packet ]          ;42 is the type we defined on the app board
end

to wnth :i :inList		     ;pull the nth word out of a packet
  output (nth 2 * :i :inList) + 256 * (nth 2 * :i + 1 :inList)
end

to retrieve-packet	;reads the packet memory location on the MSP430
  output rl $1fc0 40
end

to calibrate :n :inList
  let [adc0  nth 0 :inList
       temp0 nth 1 :inList
       adc1  nth 2 :inList
       temp1 nth 3 :inList
       slope ( :temp1 - :temp0 ) / (:adc1 - :adc0 )]
  output two-digit ( :temp0 + (:n - :adc0) * :slope )
end

;###################
;### development ###
;###################
to PacketData :packet
  let [pktName word "pktData (nth 0 :packet)	; Default list name
       pktLen count :packet]			; Packet length
  ifelse not name? :pktName			; Define if not defined
    [make :pktName [] put :pktName "pktLen :pktLen]
    [if not list? thing :pktName		; Set to empty list if other
       [make :pktName [] put :pktName "pktLen :pktLen]]
  ifelse not :pktLen = get :pktName "pktLen	; Data-in matching format check
    [error word "|Packet length/data mismatch: | :pktName]
    [make :pktName se thing :pktName :packet]	; Append new data to list
end
